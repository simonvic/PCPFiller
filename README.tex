\documentclass[12pt]{report}
\usepackage{blindtext}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{parskip}

\geometry{a4paper}
\lstset{
	basicstyle=\small\ttfamily,
	columns=flexible,
	breaklines=true
}

\title{PCPFiller}
\author{Simone Vicinanza}

\begin{document}

\maketitle

\tableofcontents

\newpage
\section{PCPFiller}

\textbf{PCPFiller} (PC Part Picker Filler) è una utility CLI destinata al
preprocessing di dataset.

Trovare datasets di componenti hardware per PC per un qualsiasi progetto di ML/DL, che siano
decenti e reperibili gratuitamente non è per niente facile; la maggior parte dei datasets
disponibili online sono incompleti, molto obsoleti, troppo piccoli per il training di una AI e
spesso anche incorretti.

\textbf{PCPFiller} is offre di costruire e fornire datasets completi e di dimensioni sufficienti per allenare
una AI per scopi didattici e non.

\section{Quick start}

PCPFiller consiste in un helper script python (\texttt{PCPFetcher.py}) il quale ha il compito di
scaricare dei dataset iniziali, i quali saranno poi utilizzati dal modulo Java che si occuperà del
"filling" dei dati.

Per una list di comandi e opzioni di `PCPFetcher.py`, consultare la help page con il seguente comando:
\begin{verbatim}$ python ./PCPFetcher.py --help\end{verbatim}

Per il modulo in java invece:
\begin{verbatim}$ java -jar ./PCPFiller.jar --help\end{verbatim}

\textbf{NOTA}: per semplicità, da ora in poi il modulo Python e il modulo Java saranno invocati
rispettivamente con i comandi:
\begin{verbatim}
$ PCPFetcher [opzioni]
$ PCPFiller [opzioni]
\end{verbatim}

Esempio completo di fetching e filling di un dataset (memorie RAM):
\begin{verbatim}
$ mkdir parts
$ PCPFetcher --fetch memory --region it --output-dir parts
$ PCPFiller --part memory --from-json parts/memory.json \
	--save-model /tmp/memory.model \
	--save-dataset /tmp/dataset.arff \
	--out-format ARFF
\end{verbatim}



\newpage
\subsection{Fetching di dataset iniziali}

Per prima cosa, \textbf{PCPFiller} scaricherà una lista di componenti hardware dal noto sito
\underline{\textit{PCPartPicker.com}.} In tale lista sono inclusi componenti principali, quali
CPU, GPU, RAM, mouse, monitor, HDD, e altre periferiche secondarie.
Per scaricare i componenti, eseguire il seguente comando:
\begin{verbatim}$ PCPFetcher --fetch <tipo componente>\end{verbatim}
Per sapere la lista dei componenti attualmente supportati, eseguire il seguente comando:
\begin{verbatim}$ PCPFetcher --supported-parts\end{verbatim}
Il download dei componenti è possibile grazie alle ottime API per python fornite da
\underline{\textit{PCPartPicker.com}} stesso (\underline{\textit{https://pypi.org/project/pcpartpicker}}),
ottenibili con \textit{pip}.

\textbf{NOTA}: quando si scaricano i componenti, assicurarsi di settare la \textit{region} correttamente.
\begin{verbatim}$ PCPFetcher --fetch <tipo componente> --region <regione>\end{verbatim}
Effettuare il fetching con una regione errata potrebbe risultare in download di dataset diversi
o addirittura un fallimento del download.

Per sapere la lista delle regioni attualmente supportate, eseguire il seguente comando
\begin{verbatim}$ PCPFetcher --supported-regions\end{verbatim}

\newpage
\subsection{Filling del dataset}

\textbf{PCPFiller} (modulo Java) si occpuerà poi di fare il parsing di tali componenti, manipolando
alcuni dati per facilitarne l'elaborazione, per poi convertirli in formato \textit{CSV}, in modo da
renderli utilizzabili da altri strumenti come Weka (GUI e API) per eventuale analisi dati, e con lo
scopo di poter procedere al "filling" di eventuali dati mancanti.

\textbf{NOTA}: le directory di input/output di PCPFiller sono di default \textit{./parts} e
\textit{./parts/formatted}. Tali percorsi possono essere cambiati; consultare la help page.

Il modulo Java si occuperà del filling dei dati attraverso un modello di ML, che può essere allenato e salvato...
\begin{verbatim}
$ PCPFiller --part <pcpart> --from-json <json-dataset> \
	--save-model <model-file>
\end{verbatim}

... oppure caricato se già allenato in precedenza
\begin{verbatim}
$ PCPFiller --part <pcpart> --from-json <json-dataset> \
  --load-model <model-file>
\end{verbatim}

Il dataset in output dopo la fase di filling, potrà essere salvato nei vari formati supportati
\begin{verbatim}
$ PCPFiller --part <pcpart> --from-json <json-dataset> \
  --save-dataset <output-dataset> \
  --out-format <output-format>
\end{verbatim}

\newpage
\section{Descrizione dell'agente intelligente}

L'obiettivo dell'agente è quello di valutare la relazione tra le varie statistiche di un componente,
per poi essere in grado di completare eventuali dati mancanti (continui e nominali).

\subsection{PEAS}

\begin{itemize}
	\item\textbf{Performance}\\
		La performance dell'agente è dettata dalla precisione e accuratezza dei dati mancanti predetti
	\item\textbf{Enviroment}
		\begin{itemize}
			\item \textbf{Completamente osservabile}, dato che ha accesso a tutte le informazioni di un componente
			\item \textbf{Deterministico}, in quanto i dati predetti dipendono solamente dallo stato iniziale dei componenti e dalle modifiche dell'agente
			\item \textbf{Sequenziale}, in quanto i dati in output possono variare in baso alle iterazioni precedenti
			\item \textbf{Statico}, i dati non variano mentre l'agente sta operando
			\item \textbf{Singolo agente}, in quanto PCPFiller è l'unico a manipolare i dati
			\item \textbf{Continuo}, la decisione del dato predetto si evolve in modo continuo
		\end{itemize}
	\item\textbf{Actuators}\\
		Gli attuatori consistono nei dati predetti inseriti nel dataset
	\item\textbf{Sensors}\\
		I sensori dell'agente consistono nei dati già presenti di un dato componente nel dataset
\end{itemize}

\subsection{Osservazioni sull'agente}

\textbf{PCPFiller}, con qualche modifica, potrebbe essere adattato per poter lavorare in un ambiente
dinamico e multi agente, in modo da poter predirre i risultati in modo dinamico dato che il mondo
economico è sempre in evoluzione.

Si potrebbe tener conto del trend di popolarità del manufacturer del componente
hardware, eventuali festività che potrebbero portare a cambiamenti (ad esempio al prezzo) e tante
altre variabili dinamiche.

Però, come menzionato prima, lo scopo di PCPFiller è solo quello di completare e fornire datasets per
altri eventuali progetti didattici di ML/DL.

\newpage
\section{Scelta di dataset di partenza}
Per poter fornire un datasets utilizzabile, PCPFiller necessità di alcuni dati di partenza per il
training del modello di ML che avrà poi lo scopo di predirre i dati mancanti.

L'idea della creazione di un dataset da zero è stata scartata immediatamente per evitare di introdurre
un ulteriore possibilità di errore.

Quindi, inizialmente si aveva pensato di fare scraping su siti di eShopping (es: Amazon, NewEgg etc.),
ma anche ciò è risultato impossibile da realizzare, dato che un singolo sito non forniva abbastanza dati,
e utilizzare piu siti significava dover rendere PCPFiller compatibile con una moltitudine di formati
dati, il che sarebbe diventato presto impossibile da mantere con un qualisasi cambiamento dei suddetti siti.\\
Oltretutto, lo scraping potrebbe aver implicazioni legali, in quanto la maggior parte dei siti non lo permettte.

Si è quindi ricorso a \underline{\textit{PCPartPicker.com}}, un sito che offre un'interfaccia per
creare delle PC build selezionando i vari componenti; il database di PCPartPicker contiente una buona
mole di dati, e come menzionato in precendenza, offre anche delle API per poter accedere a tali dati.

Le GPU e RAM erano i dataset di partenza con piu dati disponibili.
\begin{itemize}
	\item Nel caso delle GPU, le entries sono ~4400.\\
		Rimuovendo le entries incomplete si arriva a ~350, quindi con una notevole perdita del ~90\%.
	\item Nel caso delle RAM, le entries sono ~7000.\\
		Rimuovendo le entries incomplete si arriva a ~1800, quindi con una perdita del ~70\%.
\end{itemize}
Come previsto anche \underline{\textit{PCPartPicker.com}}, nonostante i dataset \\relativamente grandi,
presenta una notevole mole di dati mancanti.

Si è quindi deciso di operare inizialmente al filling del prezzo delle RAM e in futuro di espandere
il modello su altri attributi e su altri tipi di componenti.

\newpage
\section{Analisi dati disponibili}

Segue una descrizione generale dei dati disponibili per le RAM e l'eventuale utilità per lo scopo predisposto da PCPFiller
\begin{itemize}
	\item \textbf{Brand} (\textit{nominal})
		\begin{itemize}
			\item Descrizione: Nome del brand della casa produttrice
			\item Utilità: Potrebbe essere molto utile soprattutto nella predizione di prezzo. Molti brand sono noti per sovrapprezzare i propri prodotti.
		\end{itemize}
	\item \textbf{Model} (\textit{nominal})
		\begin{itemize}
			\item Descrizione: Nome del modello
			\item Utilità: Non molto utile, in quando è insolito che due prodotti condividano lo stesso nome; porterebbe solamente all'inquinamento della predizione
		\end{itemize}
	\item \textbf{Module Type} (\textit{nominal})
		\begin{itemize}
			\item Descrizione: Tipo del modulo (DDR2/3/4).\\Rappresenta la "generazione" del modulo
			\item Utilità: Molto utile, dato che tipo di moduli diversi fanno variare molto prezzo\\ ed altre statistiche come frequenza e dimensione modulo
		\end{itemize}
	\item \textbf{Speed (cycles)} (\textit{numeric})
		\begin{itemize}
			\item Descrizione: Frequenza del modulo, rappresentata in hertz (convertita in MHz in fase di preprocessing)
			\item Utilità: Decisamente utile, in quanto strettamente correlata con altri parametri
		\end{itemize}
	\item \textbf{Modules number} (\textit{numeric})
		\begin{itemize}
			\item Descrizione: Quantità di moduli
			\item Utilità: Strettamente correlata all dimensione e prezzo di un singolo modulo (1x8GB, 2x4GB, 2x16GB etc.)
		\end{itemize}
	\item \textbf{Price / GB} (\textit{numeric})
		\begin{itemize}
			\item Descrizione: Prezzo in Euro per un GB
			\item Utilità: Dato derivato da prezzo e dimensione/quantità dei moduli.
		\end{itemize}
	\item \textbf{Color} (\textit{nominal})
		\begin{itemize}
			\item Descrizione: Colore dell'involucro
			\item Utilità: Alcuni colori (es: Gold, Silver) potrebbero essere correlati a prezzo e brand.
		\end{itemize}
	\item \textbf{FW Latency} (\textit{numeric})
		\begin{itemize}
			\item Descrizione: First Word Latency, latenza (ns) tempo di accesso (performance del modulo)
			\item Utilità: Strettamente correlato ad altri parametri
		\end{itemize}
	\item \textbf{CAS timing} (\textit{numeric})
		\begin{itemize}
			\item Descrizione: Latenza di "Column Access Strobe"
			\item Utilità: Strettamente correlato ad altri parametri
		\end{itemize}
	\item \textbf{ECC} (\textit{nominal})
		\begin{itemize}
			\item Descrizione: Error Correction, capacità di correzioni errori (convertita in true/false in fase di preprocessing)
			\item Utilità: Solitamente la funzionalità di ECC è presente in moduli più pregiati. Quindi correlata ad altri parametri
		\end{itemize}
	\item \textbf{Price} (\textit{numeric})
		\begin{itemize}
			\item Descrizione: Prezzo in Euro
			\item Utilità: Decisamente utile
		\end{itemize}
\end{itemize}

Anche senza un'attenta analisi dei dati, possiamo confidentemente rimuovere il campo \textit{Model} e \textit{Price per GB}.

\newpage
Analizzando i dati con Weka, possiamo risalire alle seguenti informazioni

\includegraphics[width=\linewidth]{tex/img/attributes_stats.png}

Dei dati piu rilevanti, possiamo dire:
\begin{itemize}
	\item La generazione piu offerta è DDR4, seguita da DDR3 e DDR2
	\item La frequenza media e di circa 2500 MHz con una standard deviation di ~840
	\item La maggior parte dei prodotti vengono venduti in batch da 2 con una dimensione media di 10GB
	\item Moduli con ECC non sono molto comuni
	\item Il prezzo può arrivare anche a 2800 Euro, con una media di ~200 Euro e standard deviation di 220
\end{itemize}

\newpage
Dato che ci interessa principalmente la previsione di campi correlati al prezzo,
commentiamo la loro relazione

\textbf{NOTA}: è stato applicato un po' di jitter sui dati per migliorarne la visualizzazione

\subsubsection{Brand}
\includegraphics[width=\linewidth]{tex/img/price_brand.png}

Come previsto, alcuni brand più blasonati sono soliti scegliere prezzi piu alti per i propri prodotti

\subsubsection{Generazione modulo}
\includegraphics[width=\linewidth]{tex/img/price_moduleType.png}

Nessuna sorpresa, le ultime generazioni hanno un prezzo piu elevato.

Lo stesso possiamo dire per gli altri parametri di performance del modulo: 
maggiori performance risultano in un prezzo piu alto.

\subsubsection{Frequenza}
\includegraphics[width=\linewidth]{tex/img/price_speed.png}
\subsubsection{Dimensione modulo}
\includegraphics[width=\linewidth]{tex/img/price_moduleSize.png}
\subsubsection{First Word Latency}
\includegraphics[width=\linewidth]{tex/img/price_fwlatency.png}
\subsubsection{Overview}
\includegraphics[width=\linewidth]{tex/img/attributes_overview.png}
Una overview delle relazioni tra i vari campi


\newpage
\section{Analisi relazione tra attributi}

Per confermare le osservazioni fatte e per avere una visione più accurata della relazione tra
gli attributi, utilizziamo ancora una volta Weka.

\textit{SPOILER} Il campo color è stato scartato. Nonostante il colore potrebbe essere parzialmente
utile per la previsione del prezzo, in seguito alle precedenti osservazioni (e futuri test di
regressione), si è deciso di rimuoverlo perchè comportava solamente un incremento di complessità per
il nostro modello, senza apportare netti benefici.

\subsection{Correlation Attribute Evaluation}
L'algoritmo \textit{CorrelationAttributeEval} valuta il "valore" di un attributo misurando la
\textbf{correlazione di Pearson} tra di esso e l'attributo scelto come classe.

Si sceglie quindi il prezzo come classe, e come metodo di ricerca si usa il \textit{Ranker}.

\textbf{NOTA}: L'analisi viene effettuata su tutto il dataset (non vengono usate partizioni)
\begin{table}[!htb]
	\centering
	\begin{tabular}{ll}
		Valore  & Campo             \\
		0.6974  & Modules number    \\
		0.4739  & Module size       \\
		0.4371  & Speed             \\
		0.3142  & CAS timing        \\
		0.2878  & Module type (gen) \\
		0.1201  & Brand             \\
		0.0917  & Color             \\
		0.0208  & ECC               \\
		-0.3646 & FW latency       
	\end{tabular}
\end{table}

Come previsto il numero dei moduli, la dimensione e la frequenza sono i parametri che piu impattano
il prezzo, seguiti poi dai vari parametri di performance.

\textbf{NOTA}: del campo \textit{FW latency}, si dovrebbe prendere il valore assoluto, dato che con
l'aumentare della latenza, le performance diminuiscono, e quindi anche il prezzo.

Ripetiamo l'analisi anche con una PCA.

\newpage
\subsection{Principal Components Analysis}
Anche in questo caso si sceglie il prezzo come classe, e come metodo di ricerca si usa il \textit{Ranker}.

\textbf{NOTA}: L'analisi viene effettuata su tutto il dataset (non vengono usate partizioni)

\begin{lstlisting}
Ranked attributes:
0.8454    1 -0.443speed-0.436module_type=DDR4-0.423cas_timing+0.409module_type=DDR3+0.282first_word_latency...
0.7829    2 0.526error_correction=True+0.356module_size+0.341brand=Samsung+0.32 brand=Crucial+0.303first_word_latency...
0.735     3 0.735brand=Corsair-0.54brand=G.Skill+0.264number_of_modules-0.137brand=Patriot+0.132module_size...
0.6891    4 0.448brand=G.Skill-0.371brand=Patriot-0.328module_type=DDR2+0.263number_of_modules-0.261brand=ADATA...
0.647     5 0.498module_type=DDR2+0.356brand=OCZ-0.353brand=Kingston+0.282brand=Mushkin+0.257brand=G.Skill...
0.6078    6 0.554brand=Kingston+0.403brand=OCZ+0.334module_type=DDR2-0.262brand=Patriot-0.237brand=GeIL...
0.5707    7 -0.644brand=Crucial+0.311brand=Kingston-0.296brand=Klevv-0.231brand=OCZ+0.229brand=Samsung...
0.5346    8 0.647brand=Patriot-0.54brand=Team-0.365brand=Mushkin+0.231brand=Crucial-0.185brand=ADATA...
0.4987    9 0.494brand=Team-0.488brand=ADATA+0.34 brand=Samsung+0.32 brand=Patriot-0.316brand=Crucial...
0.4631   10 0.518brand=ADATA+0.464brand=Thermaltake-0.326brand=Team+0.312brand=Samsung-0.294brand=Crucial...
[...]
\end{lstlisting}

\section{Processing dei dati}
\subsection{Linear regression}
\subsection{RandomTree}
\subsection{RandomForest}
\subsection{M5P}

\section{Scelta dell'algoritmo}
\section{Implementazione}
\subsection{PCPFiller.java}
\subsection{PCPClassifier.java}
\subsection{PCPart.java}

\section{Cosa verrà dopo?}

%\lstinputlisting[language=Java, firstline=13]{PCPFiller/src/main/java/it/simonvic/pcpfiller/classifiers/PCPartClassifier.java}
\end{document}
